/* BSD 2-Clause License - see OPAL/LICENSE for details. */
package org.opalj.ll.fpcf.analyses.cg

import org.opalj.br.Method
import org.opalj.br.analyses.{DeclaredMethods, DeclaredMethodsKey, SomeProject}
import org.opalj.ll.fpcf.analyses.ifds.{JNICallUtil, LLVMFunction}
import org.opalj.ll.llvm.value.constant.ConstantDataArray
import org.opalj.ll.llvm.value.{Argument, Call, GetElementPtr, GlobalVariable, Load, Store, Value}
import org.opalj.ll.llvm.StructType

object JNICallDetectionAnalysis {

    def analyze(call: Call, project: SomeProject): Option[Method] = {
        implicit val declaredMethods: DeclaredMethods = project.get(DeclaredMethodsKey)

        // first, try detection approach for LLVM IR generated from source code via struct.JNINativeInterface_
        resolveCompiledJNICall(call) match {
            case Some(method) => return Some(method)
            case None =>
        }

        // if unsuccessful, try JNI call detection approach for LLVM IR generated by a binary lifter
        resolveLiftedJNICall(call)
    }

    // TODO doc
    private def resolveLiftedJNICall(call: Call): Option[Method] = {
        // TODO detect JNI calls in LLVM IR generated by a binary lifter
        None
    }

    // TODO doc
    private def resolveCompiledJNICall(call: Call)(implicit declaredMethods: DeclaredMethods): Option[Method] =
        if (isJNICall(call)) resolveJNIFunction(call) match {
            case Symbol("CallTypeMethod") => resolveMethodId(call.operand(2)) // methodID is the third parameter
            case _                        => None
        }
        else None

    /**
     * Checks whether the call is a call to the JNI interface.
     * This is done by the assumption that every such call goes to a function pointer in a struct of type "struct.JNINativeInterface_"
     */
    private def isJNICall(call: Call): Boolean = call.calledValue match {
        case load: Load => load.src match {
            case gep: GetElementPtr => gep.sourceElementType match {
                case struct: StructType if struct.name == "struct.JNINativeInterface_" => true
                case _ => false
            }
            case _ => false
        }
        case _ => false
    }

    private def resolveJNIFunction(call: Call): Symbol = call.calledValue match {
        case load: Load =>
            load.src match {
                // https://docs.oracle.com/en/java/javase/13/docs/specs/jni/functions.html has the indices
                case gep: GetElementPtr if gep.isConstant => gep.constants.tail.head match {
                    case 31      => Symbol("GetObjectClass")
                    case 33      => Symbol("GetMethodId")
                    case 49 | 61 => Symbol("CallTypeMethod") // CallIntMethod | CallVoidMethod
                    case index   => throw new IllegalArgumentException(s"unknown JNI function index ${index}")
                }
                case _ => throw new IllegalArgumentException("unknown JNI load src")
            }
        case _ => throw new IllegalArgumentException("unknown JNI call argument")
    }

    private def resolveMethodId(methodId: Value)(implicit declaredMethods: DeclaredMethods): Option[Method] = {
        val sources = methodId.asInstanceOf[Load].src.users.toSeq.filter(_.isInstanceOf[Store]).map(_.asInstanceOf[Store].src)
        val getMethodIDCall = sources.filter(_.isInstanceOf[Call]).reduce((c1, c2) => { // get closest store to methodId (load)
            if ((methodId.address - c1.address) < (methodId.address - c2.address)) c1
            else c2
        }).asInstanceOf[Call]
        if (resolveJNIFunction(getMethodIDCall) != Symbol("GetMethodId")) throw new IllegalArgumentException("unexpected call")
        if (!resolveClassIsThis(getMethodIDCall.operand(1))) // class is the second parameter
            throw new IllegalArgumentException("unexpected class argument") // TODO also resolve other classes

        val functionName = getMethodIDCall.function.name
        if (!functionName.startsWith("Java_"))
            throw new IllegalArgumentException("unexpected function name")

        val className = JNICallUtil.resolveNativeMethodName(LLVMFunction(getMethodIDCall.function)).get._1
        val name = resolveString(getMethodIDCall.operand(2)) // name is the third parameter
        val signature = resolveString(getMethodIDCall.operand(3)) // signature is the third parameter
        findJavaMethod(className, name, signature)
    }

    private def resolveString(name: Value): String = name match {
        case global: GlobalVariable => global.initializer match {
            case stringData: ConstantDataArray => stringData.asString
        }
    }

    private def resolveClassIsThis(clazz: Value): Boolean = {
        val sources = clazz.asInstanceOf[Load].src.users.toSeq.filter(_.isInstanceOf[Store]).map(_.asInstanceOf[Store].src)
        sources.filter(_.isInstanceOf[Call]).map(_.asInstanceOf[Call]).forall(call => {
            if (resolveJNIFunction(call) != Symbol("GetObjectClass")) throw new IllegalArgumentException("unexpected call")
            resolveObjectIsThis(call.operand(1)) // object is the second parameter
        })
    }

    private def resolveObjectIsThis(obj: Value): Boolean = {
        val sources = obj.asInstanceOf[Load].src.users.toSeq.filter(_.isInstanceOf[Store]).map(_.asInstanceOf[Store].src)
        sources.forall(_.isInstanceOf[Argument]) && sources.forall(_.asInstanceOf[Argument].index == 1)
    }

    private def findJavaMethod(classFqn: String, methodName: String, signature: String)(implicit declaredMethods: DeclaredMethods): Option[Method] = {
        declaredMethods.declaredMethods.filter(declaredMethod => {
            val classType = declaredMethod.declaringClassType
            (classType.fqn == classFqn &&
                declaredMethod.name == methodName &&
                declaredMethod.descriptor.toJVMDescriptor == signature)
        }).map(_.definedMethod).nextOption() // no more than one method should be found
    }
}